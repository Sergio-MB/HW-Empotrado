;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   lu. may. 20 2019
; Processor: PIC10F200
; Compiler:  MPASM (Proteus)
;====================================================================


#include p10f200.inc               ; Include register definition file
   __config 0x000			; 	
   radix dec 				; n√∫meros en decimal por defecto

;====================================================================
;							 DEFINITIONS
;====================================================================

;direccion equ 0x07

;----------------------------------- Registros especiales ----------------------------------------
   ;Direcc	equ	0x60
;====================================================================
; 							VARIABLES
;====================================================================
   cblock 0x10				;Primera posicion libre
   CNT					;CONTADOR DE RETARDOS
   CNTBIT					;CONTADOR DE BITS
   DATO					;DATO A TRANSMITIR
   LEDROJO
   LEDVERDE
   BOTON
   PREGUNTA1
   PREGUNTA2
   COMANDO
   RESPUESTA
   TMP
   TEMP
   COUNT
   SERBUF
   BOTONMEMORY
   endc
;====================================================================
; 					RESET and INTERRUPT VECTORS
;====================================================================

; Reset Vector
RST   code  0x0 

   MOVLW 0xE
   TRIS GPIO
   movlw 0x0F 				;Prescaler 1/128 para WDT
   option
   CLRW

;====================================================================
; CODE SEGMENT
;====================================================================

loop_main:

  ;CALL RXBYTE			;prueba de comunicacion
  ;MOVLW  0x62	;b
  ; CALL TXBYTE 
;FINI: GOTO FINI
  ;FURRRULA NEXT 5
   CALL RXBYTE		;guarda byte en PREGUNTA
   MOVF COMANDO, W	;Muevo PREGUNTA a W
   XORLW 0x81		;Calulo la XOR entre el valor de W y 0x81
   BTFSS STATUS, 2	;Compruebo si son iguales fijandome en el flag Z
   GOTO loop_main		;si no son iguales, vuelva a empezar
   
   
  
   
   MOVF BOTONMEMORY, W
   MOVWF RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor

   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 1		;Compruebo el gpio1, si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor
   
   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 2		;Compruebo el gpio2 si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   
   
   CALL RXBYTE		;captura del byte
   MOVF RESPUESTA, W
   CALL  TXBYTE
   MOVF COMANDO, W	;transmitimos el byte guardado en COMANDO a W
   BCF STATUS, 2		;limpiamos flag Z
   XORLW 0x00		;comparo con la mascara 0x00 para ver si es el comando 000 el recibido
   BTFSC STATUS, 2	;Compruebo si son iguales fijandome en el flag Z
   CALL	TX7
   
   MOVF COMANDO, W
   BCF STATUS, 2
   XORLW 0x01
   BTFSC STATUS, 2	;Compruebo si son iguales fijandome en el flag Z
   CALL	TX1
   
   MOVF COMANDO, W
   BCF STATUS, 2
   XORLW 0x02
   BTFSC STATUS, 2	;Compruebo si son iguales fijandome en el flag Z
   CALL	TX2
   
   MOVF COMANDO, W
   BCF STATUS, 2
   XORLW 0x03
   BTFSC STATUS, 2	;Compruebo si son iguales fijandome en el flag Z
   CALL	TX3
   
   MOVF COMANDO, W
   BCF STATUS, 2
   XORLW 0x05
   BTFSC STATUS, 2	;Compruebo si son iguales fijandome en el flag Z
   CALL	TX4
   
   MOVF COMANDO, W
   BCF STATUS, 2
   XORLW 0x06
   BTFSC STATUS, 2	;Compruebo si son iguales fijandome en el flag Z
   CALL	TX5
   
   MOVF COMANDO, W
   BCF STATUS, 2
   XORLW 0x07
   BTFSC STATUS, 2	;Compruebo si son iguales fijandome en el flag Z
   CALL	TX6
   
   MOVF COMANDO, W
   BCF STATUS, 2
   XORLW 0x04
   BTFSC STATUS, 2	;Compruebo si son iguales fijandome en el flag Z
   CALL	TX8
   
  

   ;GOTO loop_dale
   ;MOVLW 0xF		;apago uart
   ;TRIS GPIO
   
   BSF GPIO, 0
   GOTO loop_main
 
   
 
     
      
FIN: 
  
      goto FIN

   
TX1:
   ;MOVLW 0xC
   ;TRIS GPIO  
   ;BCF GPIO, 2
   MOVLW 0x04
   XORWF GPIO, W
   TRIS GPIO
  MOVF BOTONMEMORY, W
   MOVWF RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor

   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 1		;Compruebo el gpio1, si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor
   
   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 2		;Compruebo el gpio2 si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RETLW 0
  ;--------------------------------------------------------
TX2:
   ;MOVLW 0xA
   ;TRIS GPIO 
   ;BCF GPIO, 1
   MOVLW 0x02
   XORWF GPIO, W
   TRIS GPIO

  MOVF BOTONMEMORY, W
   MOVWF RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor

   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 1		;Compruebo el gpio1, si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor
   
   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 2		;Compruebo el gpio2 si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   
   RETLW 0
   ;-----------------------------------------------------

   
TX3:
   
   MOVLW 0x8
   TRIS GPIO 
   ; 
   ;BCF GPIO, 2
   ;BCF GPIO, 1

  MOVF BOTONMEMORY, W
   MOVWF RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor

   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 1		;Compruebo el gpio1, si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor
   
   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 2		;Compruebo el gpio2 si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   
   RETLW 0
  ;--------------------------------------------------------
 
   
TX4:
   ;MOVLW 0xC
   ;TRIS GPIO  
   BSF GPIO, 2
  MOVF BOTONMEMORY, W
   MOVWF RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor

   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 1		;Compruebo el gpio1, si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor
   
   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 2		;Compruebo el gpio2 si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   
   RETLW 0
  ;--------------------------------------------------------
TX5:
   ;MOVLW 0xA
   ;TRIS GPIO 
   BSF GPIO, 1

     MOVF BOTONMEMORY, W
   MOVWF RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor

   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 1		;Compruebo el gpio1, si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor
   
   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 2		;Compruebo el gpio2 si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RETLW 0
   ;-----------------------------------------------------

   
TX6:
   MOVLW 0xE
   TRIS GPIO 
     MOVF BOTONMEMORY, W
   MOVWF RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor

   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 1		;Compruebo el gpio1, si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor
   
   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 2		;Compruebo el gpio2 si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   BSF GPIO, 1 
 
   RETLW 0
  ;---------------------------------------------------------
  ; METODO para capturar el estado de las GPIO del PIC
TX7:
   
   MOVF BOTONMEMORY, W
   MOVWF RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor

   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 1		;Compruebo el gpio1, si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor
   
   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 2		;Compruebo el gpio2 si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA

   
   
   RETLW 0
   ;-----------------------------------------------------
TX8:
   CLRF BOTONMEMORY
  MOVF BOTONMEMORY, W
   MOVWF RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor

   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 1		;Compruebo el gpio1, si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RLF RESPUESTA, F	;Roto RESPUESTA a la izquierda para almacenar el siguiente valor
   
   MOVLW 0			;Cargo 0 en W
   BTFSC GPIO, 2		;Compruebo el gpio2 si esta a 0 salto la siguiente
   MOVLW 1			;si esta a 1 cargo 1 en W
   IORWF RESPUESTA, F	;hago una OR entre W y RESPUESTA y guardo en RESPUESTA
   RETLW 0

  ;--------------------------------------------------------
TXBYTE: 
      MOVWF DATO
   
      MOVLW  8
      MOVWF CNTBIT
 
      BCF GPIO,0
      
      MOVLW 7
      MOVWF CNT
           
loop_reetardo:	DECFSZ CNT , F
			GOTO loop_reetardo
txbit:	  
 
     MOVF DATO,W
     MOVWF GPIO
     RRF DATO, F
     
     MOVLW 6
     MOVWF CNT
loop_retardo2: DECFSZ CNT, F
			GOTO loop_retardo2
     nop
     DECFSZ CNTBIT ,F
     GOTO txbit
     
     BSF GPIO,0
     MOVLW 6
     MOVWF CNT
loop_retardo3: DECFSZ CNT, F
			GOTO loop_retardo3    
     RETLW 0
     
 
 
 
RXBYTE:
      MOVLW 0x01
      
      BTFSS GPIO, 3	;Compruebo si son iguales fijandome en el flag Z
      IORWF BOTONMEMORY, f
      BTFSC GPIO,0
      GOTO RXBYTE 
      MOVLW  8
      MOVWF CNTBIT
      CLRF COMANDO
      CALL half_baud
      BTFSC GPIO,0
      GOTO RXBYTE 
RXBYTE1:
      CALL baud
      BCF STATUS,0
      RRF COMANDO, F
      BTFSC GPIO, 0
      BSF COMANDO, 7 
      DECFSZ CNTBIT ,F
      GOTO RXBYTE1
      CALL baud
      MOVF COMANDO, W
      RETLW 0

baud:
	 movlw D'2' ; 1 US (BAUD RATE CONSTANT)
	 movwf COUNT ; 1 US
baud1:
	 decfsz COUNT,F ; 1 US (+ 1 US MORE IF SKIP)
	 goto baud1 ; 2 US
 ; FALL THRU...AFTER 1+1+3x68+1 = 207 US
half_baud:
	 movlw D'2' ; 1 US
	 movwf COUNT ; 1 US
hbaud1:
	 decfsz COUNT,F ; 1 US (+ 1 US MORE IF SKIP)
	 goto hbaud1 ; 2 US
	 retlw 0 ; ...AFTER 1+1+3x68+1 = 207 US (X2=414 US)

;====================================================================





      END